// user authentication

#ifndef FILESERVER_USER_MANAGEMENT_H
#define FILESERVER_USER_MANAGEMENT_H

#include "encryption/encryption.h"
#include "helpers/helper_functions.h"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <random>
#include <regex>
#include <string>

using namespace std;

enum UserType { admin, user };

/// Add a user to the system
/// \param userName     The username to add
/// \param directory    The directory to add the user to
/// \param isAdmin    Whether the user is an admin
void addUser(const string& userName, string directory, bool isAdmin= false)
{
// Normalize directory path to ensure it ends with a slash
    string normalizedDir = directory + "/";

    // Validate username length
    if (userName.length() > 50) {
        cout << "Error: Username is too long." << endl;
        return;
    }

    // Admin-specific username validation
    if (!isAdmin && userName == "admin") {
        cout << "Error: Invalid Username." << endl;
        return;
    }

    // Username character validation
    std::regex validUsernameRegex("^[a-zA-Z0-9]*$");
    if (!std::regex_match(userName, validUsernameRegex)) {
        cout << "Error: Username contains invalid characters." << endl;
        return;
    }

    // Check if user already exists
    string publicKeyPath = normalizedDir + "public_keys/" + userName + ".pub";
    string privateKeyPath = normalizedDir + "private_keys/" + userName + "_keyfile";
    if (std::filesystem::exists(publicKeyPath) || std::filesystem::exists(privateKeyPath)) {
        cout << "User " << userName << " already exists." << endl;
        return;
    }

    // Generate SSH key pair
    string privateKeyFile = normalizedDir + "private_keys/" + userName;
    string generateKeyCommand = "ssh-keygen -t rsa -b 2048 -C 'created_by_encrypted_fs' -f " + privateKeyFile + " -N '' -q";
    system(generateKeyCommand.c_str());

    // Move and rename key files
    std::filesystem::rename(privateKeyFile + ".pub", publicKeyPath);
    std::filesystem::rename(privateKeyFile, privateKeyPath);

    // Post-creation steps
    cout << "User " << userName << " added successfully." << endl;

    // create metadata key file if not present
    fstream file(normalizedDir + "/metadata/" + userName + "_key", ios::out | ios::binary);
    if (!file.is_open()) {
        std::cout << "Failed to create user metadata key file" << std::endl;
        return;
    }
    // create 256-bit key
    uint8_t key[KEY_SIZE];
    RAND_bytes(key, KEY_SIZE);
    file.write((char *) key, KEY_SIZE);
    file.close();

    ofstream outfile(normalizedDir + "metadata/unames", ios_base::app);
    outfile << userName << "\n";
    outfile.close();
    createInitFsForUser(userName, normalizedDir);
}

/// Check if a keyfile is valid
/// \param userName    The username to check
/// \return
bool isValidKeyfile(const std::string& userName)
{

    // Define paths for the user's private and public keys
    std::filesystem::path privateKeyPath = "private_keys/" + userName + "_keyfile";
    std::filesystem::path publicKeyPath = "public_keys/" + userName + ".pub";

    // Generate the expected public key from the private key file using ssh-keygen
    std::string extractPublicKeyCmd = "ssh-keygen -y -f " + privateKeyPath.string();
    std::array<char, 128> buffer;
    std::string expectedPublicKey;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(extractPublicKeyCmd.c_str(), "r"), pclose);
    if (!pipe) {
        cerr << "Failed to run command: " << extractPublicKeyCmd << endl;
        return false;
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        expectedPublicKey.append(buffer.data());
    }

    // Read the actual public key from file
    std::ifstream publicKeyFile(publicKeyPath);
    std::string actualPublicKey((std::istreambuf_iterator<char>(publicKeyFile)), std::istreambuf_iterator<char>());

    // Verify the public key is correctly generated by the system
    bool isCreatedByEncryptedFs = actualPublicKey.find("created_by_encrypted_fs") != std::string::npos;

    // Check if the user is listed in the system's user list
    bool isUserListed = false;
    std::ifstream userList("metadata/unames");
    std::string line;
    while (getline(userList, line)) {
        if (line.find(userName) != std::string::npos) {
            isUserListed = true;
            break;
        }
    }

    // The keyfile is valid if the extracted public key matches the stored one, it's correctly flagged, and the user is listed
    return expectedPublicKey == actualPublicKey && isCreatedByEncryptedFs && isUserListed;
}

/// Get the type of user from a keyfile
/// \param keyFileName    The name of the keyfile
/// \return          The type of user
string getTypeOfUser(const std::string& keyFileName)
{
    // Attempt to get file status; if unsuccessful, terminate the program
    struct stat fileInfo;
    string privateKeyPath = "private_keys/" + keyFileName;
    if (stat(privateKeyPath.c_str(), &fileInfo) != 0) {
        cerr << "Invalid keyfile" << endl;
        exit(EXIT_FAILURE); // Consider throwing an exception instead of exiting
    }

    // Extract username from the keyfile name by removing the suffix and any spaces
    string userName = keyFileName.substr(0, keyFileName.find_first_of("_ "));

    // Validate the keyfile based on the extracted username
    if (isValidKeyfile(userName)) {
        cout << "Logged in as " << userName << endl;
        return userName;
    }

    // If validation fails, report an invalid keyfile and terminate the program
    cerr << "Invalid keyfile" << endl;
    exit(EXIT_FAILURE); // Consider throwing an exception instead of exiting
}

#endif
